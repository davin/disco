import sys, os
from scipy import sparse
from numpy import random, float64, sqrt
from disco.core import Disco
from disco.func import chain_reader
from disco.dfs.gluster import files
from matrixWrap import MatrixWrapper
from scipy.sparse import coo_matrix
import scipy.linalg as linalg
from misc import *
from lapack import *

disco = Disco("disco://discomaster")
random.seed(13)

def testPower1(tol=0.0001):
	# test with a random dense symmetric matrix distributed in the cluster 
	n = 1000
	transA = False
	sparsity = 0.0
	print "initializing random matrix..."
	sys.stdout.flush()
	Awrap = randomSymmetricMatrix(n, sparsity, disco, dtype=float64)
	A = Awrap.unwrapMatrix(n, n, dtype=float64)
	# compute eigenvector
	print "computing actual dominant eigenvector..."
	sys.stdout.flush()
	import time
	startTime = time.time()
	totalWorkers = 128
	print "total time for wrapping matrix=%f mins" % ((time.time()- startTime)/60.0)
	startTime = time.time()
	v1 = eigenvector(transA, n, Awrap, disco, totalWorkers).unwrapMatrix(n, 1, dtype=float64).todense()
	print "total time for computing eigenvector=%f mins" % ((time.time()- startTime)/60.0)
	sys.stdout.flush()
	# compute expected dominant eigenvector in norm2
	print "computing expected dominant eigenvector..."
	sys.stdout.flush()
	if transA:
		la,v_exp = linalg.eig(A.transpose().todense())
	else:
		la,v_exp = linalg.eig(A.todense())
	la = map(abs, list(la))
	idx = la.index(max(la))
	v1_exp = map(abs, list(v_exp[:,idx]))
	norm1 = sum([abs(i) for i in v1_exp])
	v1_exp = [i/norm1 for i in v1_exp]
	# compare expected vs. actual
	for i in range(0, n):
		diff = abs(v1[i,0] - v1_exp[i])
		assert abs(diff) <= tol, "diff of %.14f exceeds threshold" % diff

def randomSparseSymmetricMatrix(n, sparsity=0.7, dtype=float64, targetFile=None, buffSize=1000000):
	"""
	Create a height-b-width coo matrix in double precision by default to file.
	@param height Height of the matrix
	@param width Width of the matrix
	@param sparsity Density of the matrix in the range of [0-1] with 0=dense matrix.
	@param dtype Data type with default=float64
	"""
	assert sparsity<=1 and sparsity>=0, "Invalid value for sparsity"
	outfile = file(targetFile, "w")
	buff = ""
	count = 0
	for i in range(0, n):
		for j in range(i, n):
			if random.rand() >= sparsity:
				val = random.rand()
				if dtype == float64:
					buff += "%d,%d,%.14f\n%d,%d,%.14f\n" % (i, j, val, j, i, val)
				elif dtype == float:
					buff += "%d,%d,%.14f\n%d,%d,%f\n" % (i, j, val, j, i, val)
				else:   
					raise Exception('invalid dtype')
				count += 1
				if count % buffSize == 0:
					outfile.write(buff)
					buff = ""
	outfile.write(buff)
	outfile.close()

def testPower2(tol=0.001):
	# test with a random dense symmetric matrix generated on local file
	n = 100
	transA = False
	sparsity = 0.0
	print "initializing random matrix..."
	sys.stdout.flush()
	mtxFile = "/scratch/davin/A_small.mtx"
	randomSparseSymmetricMatrix(n, sparsity, dtype=float64, targetFile=mtxFile, buffSize=100)
	# compute eigenvector
	print "computing actual dominant eigenvector..."
	sys.stdout.flush()
	import time
	startTime = time.time()
	totalWorkers = 128
	Awrap = MatrixWrapper.wrapMatrixFile(mtxFile, MatrixWrapper.RAW)
	print "total time for wrapping matrix=%f mins" % ((time.time()- startTime)/60.0)
	# instantiate matrix from wrapper 
	A = Awrap.unwrapMatrix(n, n, dtype=float64)
	startTime = time.time()
	v1 = eigenvector(transA, n, Awrap, disco, totalWorkers, tol=0.0001).unwrapMatrix(n, 1, dtype=float64).todense()
	print "total time for computing eigenvector=%f mins" % ((time.time()- startTime)/60.0)
	sys.stdout.flush()
	# compute expected dominant eigenvector in norm2
	print "computing expected dominant eigenvector..."
	sys.stdout.flush()
	if transA:
		la,v_exp = linalg.eig(A.transpose().todense())
	else:
		la,v_exp = linalg.eig(A.todense())
	la = map(abs, list(la))
	idx = la.index(max(la))
	v1_exp = map(abs, list(v_exp[:,idx]))
	norm1 = sum([abs(i) for i in v1_exp])
	v1_exp = [i/norm1 for i in v1_exp]
	# compare expected vs. actual
	for i in range(0, n):
		diff = abs(v1[i,0] - v1_exp[i])
		assert abs(diff) <= tol, "diff of %.14f exceeds threshold" % diff
	
def testPower3(tol=0.0001):
	# test with a random sparse symmetric matrix created distributedly
	n = 1000000
	transA = False
	sparsity = 0.9999
	totalWorkers = 128
	import time
	print "initializing random matrix..."
	startTime = time.time()
	Awrap = randomSymmetricMatrix(n, sparsity, disco, maxTotalBlocks=totalWorkers)
	print "total time for initializing random matrix=%f mins" % ((time.time()- startTime)/60.0)
	# compute eigenvector
	print "computing actual dominant eigenvector..."
	startTime = time.time()
	v1 = eigenvector(transA, n, Awrap, disco, totalWorkers, tol=0.00001).unwrapMatrix(n, 1, dtype=float64).todense()
	print "total time for computing eigenvector=%f mins" % ((time.time()- startTime)/60.0)

def testJacobi1(tol=0.001):
	from numpy import arange, random, ones
	from scipy import sparse
	from scipy.sparse import coo_matrix
	# create a random matrix
	n = 100
	Asp = sparse.lil_matrix((n,n))
	Asp.setdiag(ones(n))
	Asp[0, 99] = 1
	Asp[1, 98] = -2
	Asp[2, 0] = 1
	Asp[2, 1] = -1
	Awrap = MatrixWrapper.wrapMatrix(Asp.tocoo(), MatrixWrapper.RAW)
	# find least squares solution with scipy
	b = sparse.lil_matrix((n, 1))
	for i in range(0, n):
		b[i,0] = i
	bWrap = MatrixWrapper.wrapMatrix(b.tocoo(), MatrixWrapper.RAW)
	# find least squares solution with disco lapack
	transA = False
	sparsity = 0.0
	totalWorkers = 128
	# compute eigenvector
	import time
	print "solving for x..."
	startTime = time.time()
	x = jacobi(transA, n, Awrap, bWrap, disco, totalWorkers, tol=0.0001).unwrapMatrix(n, 1, dtype=float64).todense()
	print "total time for solving x=%f mins" % ((time.time()- startTime)/60.0)
	# compute expected x in norm1
	print "validating results..."
	# compare expected vs. actual
	xExp = sparse.lil_matrix((n, 1))
	for i in range(0, n):
		xExp[i,0] = i
	xExp[0,0] = -99 
	xExp[1,0] = 197
	xExp[2,0] = 298 
	for i in range(0, n):
		diff = abs(x[i,0] - xExp[i,0])
		assert abs(diff) <= tol, "diff of %.14f exceeds threshold" % diff

def testJacobi2(tol=0.001):
	from numpy import arange, random, ones
	from scipy import sparse
	from scipy.sparse import coo_matrix
	# create a random matrix
	n = 2 
	Asp = sparse.lil_matrix((n,n))
	Asp[0,0] = -2.2361
	Asp[1,0] = 0
	Asp[0,1] = -6.7082
	Asp[1,1] = 3.1623
	Awrap = MatrixWrapper.wrapMatrix(Asp.tocoo(), MatrixWrapper.RAW)
	# create b
	b = sparse.lil_matrix((n, 1))
	b[0,0] = -30.4105
	b[1,0] = 10.7517
	bWrap = MatrixWrapper.wrapMatrix(b.tocoo(), MatrixWrapper.RAW)
	# find least squares solution with disco lapack
	transA = False
	totalWorkers = 1
	import time
	print "solving for x..."
	startTime = time.time()
	x = jacobi(transA, n, Awrap, bWrap, disco, totalWorkers, tol=0.0001).unwrapMatrix(n, 1, dtype=float64).todense()
	print "total time for solving x=%f mins" % ((time.time()- startTime)/60.0)
	# compute expected x in norm1
	print "validating results..."
	# compare expected vs. actual
	print x
	assert abs(x[0,0] - 3.4) < tol, "expecting x[0,0]=3.4 rather than %f" % x[0,0]
	assert abs(x[1,0] - 3.4) < tol, "expecting x[1,0]=3.4 rather than %f" % x[1,0]

def testQr1(tol=0.001):
	from numpy import arange, random, ones
	from scipy import sparse
	from scipy.sparse import coo_matrix
	# create a random matrix
	m = 100 
	n = 100 
	transA = True 
	totalWorkers = 10
	Awrap = randomMatrix(m, n, 0.5, disco, maxTotalBlocks=totalWorkers, dtype=float64)
	A = Awrap.unwrapMatrix(m, n, dtype=float64).todense()
	"""
	A = sparse.lil_matrix((m,n))
	A.setdiag(ones(n))
	A[1, 0] = 1
	A[0, 1] = 2
	A[0,99] = 9
	A[10,66] = 66
	A[99,99] = 7
	A[97,0] = 9
	A[96,88] = 13
	A[44,55] = 17
	Awrap = MatrixWrapper.wrapMatrix(A.tocoo(), MatrixWrapper.RAW)
	"""
	print A
	# compute QR factorization
	Qwrap, Rwrap = qr(transA, m, n, Awrap, True, disco, maxWorkers=totalWorkers)
	if transA:
		Q = Qwrap.unwrapMatrix(n, n, dtype=float64).todense()
		R = Rwrap.unwrapMatrix(n, m, dtype=float64).todense()
	else:
		Q = Qwrap.unwrapMatrix(m, m, dtype=float64).todense()
		R = Rwrap.unwrapMatrix(m, n, dtype=float64).todense()
	print Q
	print R
	# validate result
	if transA:
		Zwrap = dgemm(False, False, n, m, n, 1.0, Qwrap, Rwrap, 0, MatrixWrapper(), disco, maxTotalBlocks=totalWorkers)
		Z = Zwrap.unwrapMatrix(n, m, dtype=float64).todense()
	else:
		Zwrap = dgemm(False, False, m, n, m, 1.0, Qwrap, Rwrap, 0, MatrixWrapper(), disco, maxTotalBlocks=totalWorkers)
		Z = Zwrap.unwrapMatrix(m, n, dtype=float64).todense()
	if transA:
		for i in range(0, n):
			for j in range(0, m):
				diff = abs(Z[i,j] - A[j,i])
				assert diff <= tol, "diff between expected A[%d,%d] and actual C[%d,%d]=%.14f exceeds threshold" % (i,j,i,j,diff)
	else:
		for i in range(0, m):
			for j in range(0, n):
				diff = abs(Z[i,j] - A[i,j])
				assert diff <= tol, "diff between expected A[%d,%d] and actual C[%d,%d]=%.14f exceeds threshold" % (i,j,i,j,diff)

def testQr2(tol=0.001):
	from numpy import arange, random, ones
	from scipy import sparse
	from scipy.sparse import coo_matrix
	# initialize A
	m, n = 5, 2
	A = sparse.lil_matrix((m,n))
	A[0:m,0] = 1
	A[0,1] = 1
	A[1,1] = 2
	A[2,1] = 3
	A[3,1] = 4
	A[4,1] = 5
	Awrap = MatrixWrapper.wrapMatrix(A.tocoo(), MatrixWrapper.RAW)
	print A.todense()
	# compute QR factorization
	transA = False
	totalWorkers = 1
	skinny = False
	Qwrap, Rwrap = qr(transA, m, n, Awrap, skinny, disco, maxWorkers=totalWorkers)
	if transA:
		Q = Qwrap.unwrapMatrix(n, n, dtype=float64).todense()
		R = Rwrap.unwrapMatrix(n, m, dtype=float64).todense()
	else:
		Q = Qwrap.unwrapMatrix(m, m, dtype=float64).todense()
		R = Rwrap.unwrapMatrix(m, n, dtype=float64).todense()
	print Q
	print R
	# validate result
	if transA:
		Zwrap = dgemm(False, False, n, m, n, 1.0, Qwrap, Rwrap, 0, MatrixWrapper(), disco, maxTotalBlocks=totalWorkers)
		Z = Zwrap.unwrapMatrix(n, m, dtype=float64).todense()
	else:
		Zwrap = dgemm(False, False, m, n, m, 1.0, Qwrap, Rwrap, 0, MatrixWrapper(), disco, maxTotalBlocks=totalWorkers)
		Z = Zwrap.unwrapMatrix(m, n, dtype=float64).todense()
	if transA:
		for i in range(0, n):
			for j in range(0, m):
				diff = abs(Z[i,j] - A[j,i])
				assert diff <= tol, "diff between expected A[%d,%d] and actual C[%d,%d]=%.14f exceeds threshold" % (i,j,i,j,diff)
	else:
		for i in range(0, m):
			for j in range(0, n):
				diff = abs(Z[i,j] - A[i,j])
				assert diff <= tol, "diff between expected A[%d,%d] and actual C[%d,%d]=%.14f exceeds threshold" % (i,j,i,j,diff)

def testLs(tol=0.001):
	from numpy import arange, random, ones
	from scipy import sparse
	from scipy.sparse import coo_matrix
	# initialize A
	m, n = 5, 2
	A = sparse.lil_matrix((m,n))
	A[0:m,0] = 1
	A[0,1] = 1
	A[1,1] = 2
	A[2,1] = 3
	A[3,1] = 4
	A[4,1] = 5
	Awrap = MatrixWrapper.wrapMatrix(A.tocoo(), MatrixWrapper.RAW)
	print A.todense()
	# initialize b
	b = sparse.lil_matrix((5,1))
	b[0,0] = 7
	b[1,0] = 10
	b[2,0] = 14
	b[3,0] = 16
	b[4,0] = 21 
	bWrap = MatrixWrapper.wrapMatrix(b.tocoo(), MatrixWrapper.RAW)
	print b.todense()
	# compute QR factorization
	transA = False
	maxWorkers = 1
	xWrap = ls(transA, m, n, Awrap, bWrap, disco, maxWorkers=maxWorkers, tol=tol)
	x = xWrap.unwrapMatrix(2, 1, dtype=float64).todense()
	print x

def main(args=None):
	#testPower1()
	#testPower2()
	#testPower3()
	#testJacobi1()
	#testJacobi2()
	#testQr1()
	#testQr2()
	testLs()

if __name__ == "__main__":
	main(sys.argv)

